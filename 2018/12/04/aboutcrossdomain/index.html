
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>麦克橘子店 - 欢迎大家来买橘子</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="google-site-verification" content="t7DfhlCK2ziWycZUA92smFKB5G9r7y8BU4sIrI89z8U">
    <meta name="keywords" content="Macrazds,"> 
    <meta name="description" content="What about you?Plentymore.,"> 
    <meta name="author" content="MacrazdHao"> 
    <link rel="alternative" href="atom.xml" title="麦克橘子店" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">关于跨域及跨域的解决方式</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">关于跨域及跨域的解决方式</h1>
        <div class="stuff">
            <span>十二月 04, 2018</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/cookie/">cookie</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/cors/">cors</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/cross/">cross</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/cross-domain/">cross-domain</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/dom/">dom</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/domain/">domain</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/jsonp/">jsonp</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/request/">request</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/session/">session</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/接口/">接口</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/请求/">请求</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/跨域/">跨域</a></li></ul>


        </div>
        <div class="content markdown">
            <p>参考原文：</p>
<p><a href="https://segmentfault.com/a/1190000015597029" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015597029</a></p>
<p><a href="https://www.cnblogs.com/chenshishuo/p/4919224.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenshishuo/p/4919224.html</a></p>
<h1><span id="前言">前言</span></h1><p>博主正在写毕设，刚刚搭建完服务器的环境，由于用的是前后端分离的方式写网站，然后就遇到了不可避免的跨域的问题，然后在网上找了点资料，加之自己试了试，然后把相关内容在这里记录一下，避免以后遇到同样的问题，希望同时也能帮到大家~~</p>
<h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#关于跨域">关于跨域</a><ul>
<li><a href="#跨域是什么同源策略是什么">跨域是什么？同源策略是什么？</a></li>
<li><a href="#为什么会出现跨域">为什么会出现跨域？</a></li>
<li><a href="#没有同源策略会发生什么">没有同源策略会发生什么？</a></li>
</ul>
</li>
<li><a href="#实现跨域">实现跨域</a><ul>
<li><a href="#接口请求">接口请求</a><ul>
<li><a href="#jsonp">JSONP</a></li>
<li><a href="#空iframe加form">空iframe加form</a></li>
<li><a href="#cors">CORS</a></li>
<li><a href="#代理">代理</a></li>
</ul>
</li>
<li><a href="#dom查询">Dom查询</a><ul>
<li><a href="#postmessage">postMessage</a></li>
<li><a href="#documentdomain">document.domain</a></li>
<li><a href="#canvas操作图片的跨域问题">canvas操作图片的跨域问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h3><span id="关于跨域">关于跨域</span></h3><h4><span id="跨域是什么同源策略是什么">跨域是什么？同源策略是什么？</span></h4><p>首先不废话，对于同源策略先总结一句：一个域分为 协议、地址、端口 三个部分，其任一不同，即为不同的域。</p>
<p>同源策略一般会针对两个方面：①接口请求 ②Dom查询。</p>
<p>不同域之间请求数据或对象等资源，即为跨域，如以下例：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th><a href="https://macrazds.cn:8080/a.html">https://macrazds.cn:8080/a.html</a></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>请求地址</td>
<td>协议</td>
<td>域名/地址</td>
<td>端口</td>
<td>路径</td>
<td>文件</td>
<td>请求是否跨域</td>
</tr>
<tr>
<td><a href="http://macrazds.cn:8080/a.html">http://macrazds.cn:8080/a.html</a></td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><a href="https://macrazdhao.cn:8080/a.html" target="_blank" rel="noopener">https://macrazdhao.cn:8080/a.html</a></td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><a href="https://macrazds.cn:3000/a.html">https://macrazds.cn:3000/a.html</a></td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><a href="https://macrazds.cn:8080/test/a.html">https://macrazds.cn:8080/test/a.html</a></td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><a href="https://macrazds.cn:8080/b.html">https://macrazds.cn:8080/b.html</a></td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<h4><span id="为什么会出现跨域">为什么会出现跨域？</span></h4><p>总的来说，就一句话，是浏览器对于Javascript的同源策略在搞鬼，不同域之间的Js无法对互相共享对象和资源等等。具体的官方解释：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p>
<p>按照上面的官方解释，就是：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>
<p>反正就是一个浏览器的安全机制，于是就出现了让我们这么蛋疼的问题。</p>
<h4><span id="没有同源策略会发生什么">没有同源策略会发生什么？</span></h4><p>因为同源策略是根据接口请求、Dom查询这两个方面来的，所以这里针对这两个场景做分析：</p>
<ol>
<li>接口请求</li>
</ol>
<p>首先说一说Cookie，一般用作网站的登陆场景，使服务端知道发送请求的是哪个用户。当你登陆了某个网站，并通过验证，服务端就会在响应头添加 Set-Cookie 字段，然后当你对该服务端发送其他请求时，浏览器就会把 cookie 加在HTTP请求头字段Cookie中，服务端接收到该请求后，就能知道发送该请求打的是哪个用户，并且已经登录过了。</p>
<p>接下来分析一下针对接口请求，没有同源策略的情境下，会发生什么危险的事情。</p>
<p>首先打个比方，你在某宝登录正在挑选商品，与此同时，某个求求好友给你发来了个不知道什么网址，在他的各种威逼利诱之下，你点开了这个迷之网址，于是故事就发生了。</p>
<p>当你好心好意地看着这个迷之网址的时候，然这个迷之网址却在背地里做着一些不可理喻的勾当！！而此时正因为你的浏览器没有同源策略！！这个迷之网址竟然向某宝发送了附带 Set-Cookie 的HTTP请求！！接下来就是上演为所欲为二人组表情包的时刻了！</p>
<p>试想一下，如果你登陆的是某银行，后果不堪设想。</p>
<p>上面说的，其实就是 CSRF攻击 ，详细可以看这篇文章：</p>
<p><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></p>
<p>然而后来我了解到，cookie是明文的，即使有同源策略也一样不安全。于是后来又发现又httpOnly这玩意儿，可以使js不能获取cookie的内容。如果没有httpOnly，通过XSS就可以获取到Cookie。然后就是通过Secure，可以保证在https的加密通信中传输以防截获。</p>
<p>另外附上：</p>
<p>XSS攻击相关文章：</p>
<p><a href="https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html" target="_blank" rel="noopener">https://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html</a></p>
<p>Cookie/Session的机制与安全</p>
<p><a href="https://harttle.land/2015/08/10/cookie-session.html" target="_blank" rel="noopener">https://harttle.land/2015/08/10/cookie-session.html</a></p>
<p>对于这一篇文章，这里我浅谈一下这两点收获：</p>
<ol>
<li>Cookie防篡改机制是怎么防篡改的？</li>
</ol>
<p>情景：首先用户发送请求到服务端，服务端在返回相应数据的时候。</p>
<ul>
<li><p>服务端由一个不为人知的字符串( 称为Secret )，然后根据Secret对所需要返回的值 somevalue=123 ，与改Secret进行计算生成 签名 6hTiBl7lVpd1P 。</p>
</li>
<li><p>于是返回 Set-Cookie: somevalue=123|6hTiBl7lVpd1P 。</p>
</li>
<li><p>在用户收到该相应的应答后，打算 篡改 该数据的值，如篡改为 somevalue=9999 ，并再次发送请求。</p>
</li>
<li><p>由于用户不知道这个仅存于服务端的Secret字符串，无法生成对应签名，只能随意填写成  Set-Cookie: somevalue=99999|??? 。</p>
</li>
<li><p>服务端收到该请求后，对该Cookie进行签名校验，便会发现重新生成的签名，与发过来的签名（???）不一致。</p>
</li>
</ul>
<ol start="2">
<li>Session是如何避免客户端Cookie存储敏感数据的？</li>
</ol>
<p>首先理解一下SessionId的来历，这里以将Session存储在redis为例（Session 可以存储在HTTP服务器的内存中，也可以存在内存数据库（如redis）中， 对于重量级的应用甚至可以存储在数据库中）：</p>
<ul>
<li><p>当用户通过了登录请求时，服务端会将该用户名存储在redis中，并生成对应在redis中的ID，该ID即为SessionID。</p>
</li>
<li><p>通过SessionID，可以从redis中取出用户对象（该用户对象存储着敏感数据）。</p>
</li>
</ul>
<p>那么Session是如何避免客户端Cookie存储敏感数据的呢？</p>
<p>这里分为两种情景来讨论，没有Session，及有Session的情景：</p>
<ul>
<li><p>没有Session：当用户需要发送以某个敏感信息为基础的请求（请求1）前，需要先请求该敏感信息，并存储到Cookie，才能继续发送那个请求1。此时Cookie存储为 somevalue=123 。</p>
</li>
<li><p>有Session：当用户需要发送以某个敏感信息为基础的请求前，无需请求该敏感信息，只需要设置Cookie为 sessionId=xxxxxx|somevalue 。</p>
</li>
</ul>
<p>综上对比，由于Cookie是明文的，可以明显看得出哪个更加安全。</p>
<ol start="2">
<li>Dom查询</li>
</ol>
<p>简单来说就是钓鱼网站，这种钓鱼网站不是通过伪造页面来实现的，而已通过iframe。即比如正常的网站地址的是macrazds.cn，然而你访问的是macrazbs.cn，此时该网站通过iframe指定src，显示的是macrazds.cn的内容。</p>
<p>当你登陆时，会发生什么呢？</p>
<p>当你登陆的时候，这个macrazbs.cn就可以通过js来获取你在iframe中登陆时输入账号密码的input的内容了，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"macrazds"</span> <span class="attr">src</span>=<span class="string">"macrazbs.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom</span></span><br><span class="line"><span class="keyword">const</span> iframe = <span class="built_in">window</span>.frames[<span class="string">'macrazds'</span>]</span><br><span class="line"><span class="keyword">const</span> node = iframe.document.getElementById(<span class="string">'你输入账号密码的Input'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`拿到了这个<span class="subst">$&#123;node&#125;</span>，我还拿不到你刚刚输入的账号密码吗`</span>)</span><br></pre></td></tr></table></figure>
<p>综上，通过接口请求、Dom查询这两点，可以清晰地了解到有了同源策略可以安全很多（并不是说绝对安全）。</p>
<h3><span id="实现跨域">实现跨域</span></h3><p>在这里，基于同源策略下，我会对接口请求、Dom查询这两个方向分别来给出具体的实现方案。</p>
<ul>
<li><p>实现环境介绍：</p>
<p>前端：Vue.js</p>
<p>后端：Node.js + Express</p>
<p>Web服务器：Apache</p>
<p>本地调试地址：</p>
<p>前端：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p>
<p>后端：<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a></p>
</li>
</ul>
<h4><span id="接口请求">接口请求</span></h4><h5><span id="jsonp">JSONP</span></h5><p>参考（推荐）：</p>
<p><a href="https://www.cnblogs.com/giggle/p/5496596.html" target="_blank" rel="noopener">https://www.cnblogs.com/giggle/p/5496596.html</a></p>
<p>本质上来讲，jsonp不过是通过一个script标签实现的跨域请求。也正因如此，所以只能实现GET请求。</p>
<p>实现原理：</p>
<ul>
<li><p>凡是拥有src属性的标签都拥有跨域的能力，比如script、img及iframe。</p>
</li>
<li><p>通过上一条，可以很直接地想到，可以利用script标签，将需要返回的数据通过js文件返回，从而获取到数据，然后供用户进一步处理。</p>
</li>
<li><p>原生js支持JSON格式的数据，因此，根据上一条，我们可以在服务端将数据以JSO你的数据格式存储在js文件当中，以实现返回数据。</p>
</li>
<li><p>根据上一点，加之用户所需要的数据不是固定一成不变的，因此需要动态生成JSON文件，以便动态地将数据填充，然后返回给用户。</p>
</li>
<li><p>为了便于前端使用数据，这逐渐形成了一种非正式的传输协议，人们将其称为JSONP，该协议允许用户传递一个函数作为参数给服务端（callback回调函数），当服务端返回数据时，就会将返回的数据以参数的形式传递给callback函数，再通过callback函数进行处理。</p>
</li>
</ul>
<p>代码实现：</p>
<p>后端（Node.js + Express）：</p>
<p>首先在根目录的routes文件夹下新建一个jsonp.js，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"收到来自jsonp的请求，内容是"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    res.jsonp(&#123;<span class="attr">msg</span>: <span class="string">"this is jsonp!!"</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>
<p>在根目录下的app.js添加以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonpRouter = <span class="built_in">require</span>(<span class="string">'./routes/jsonp'</span>);</span><br><span class="line">app.use(<span class="string">'/jsonp'</span>, jsonpRouter);</span><br></pre></td></tr></table></figure>
<p>这样，后端的代码就完成了。</p>
<p>接下来看下前端发送请求的代码是如何实现的：</p>
<ul>
<li>原生js实现：</li>
</ul>
<p>在body中添加以下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">    alert(data.msg);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:3000/jsonp?callback=test"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当看到以下弹窗的时候，即表示成功。</p>
<p><img src="/2018/12/04/aboutcrossdomain/jsonp.jpg" alt="jsonp请求结果"></p>
<ul>
<li>Vue.js实现：</li>
</ul>
<p>首先我们安装一个依赖包vue-jsonp</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install vue-jsonp --save</span><br></pre></td></tr></table></figure>
<p>打开vue项目，src目录中的main.js，添加以下两行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueJsonp <span class="keyword">from</span> <span class="string">'vue-jsonp'</span></span><br><span class="line">Vue.use(VueJsonp);</span><br></pre></td></tr></table></figure>
<p>接着在相对应的页面，及需要发送jsonp请求的函数中添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$jsonp(<span class="string">'http://localhost:3000/jsonp'</span>,&#123;<span class="attr">msg</span>: <span class="string">"this is a jsonp request!!"</span>&#125;).then(<span class="function"><span class="params">json</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是jsonp返回的信息：'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(json);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'出错了！！呜呜呜！！'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接着在控制台看到相应输出，即表示成功。</p>
<h5><span id="空iframe加form">空iframe加form</span></h5><p>由于JSONP仅限于GET请求，那如果要发送POST请求的时候，该如何办呢？</p>
<p>这时候可以通过利用空iframe加form的方法来替代，具体如何实现请继续往下看~</p>
<p>注意：该方法因为是基于form表单的，所以也仅限于GET和POST请求。</p>
<p>代码实现：</p>
<p>后端（Node.js + Express）：</p>
<p>首先在根目录的routes文件夹下新建一个jsonp.js，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"><span class="comment">/* POST users listing. */</span></span><br><span class="line">router.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"收到来自iframe的form请求，内容是"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    res.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>);</span><br><span class="line">    res.send(<span class="string">"&lt;p name='resinfo'&gt;i got the post request!!&lt;/p&gt;"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，Content-Type需要设置为text/html，否则在前端会出现MIME的警告：</p>
<blockquote>
<p>Resource interpreted as Document but transferred with MIME type application/json</p>
</blockquote>
<p>在根目录下的app.js添加以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonpRouter = <span class="built_in">require</span>(<span class="string">'./routes/iframe'</span>);</span><br><span class="line">app.use(<span class="string">'/iframe'</span>, iframeRouter);</span><br></pre></td></tr></table></figure>
<p>这样，后端的代码就完成了。</p>
<p>接下来看下前端发送请求的代码是如何实现的：</p>
<p>接着在相对应的页面，及需要发送jsonp请求的函数中添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestPost = <span class="function">(<span class="params">&#123; url, data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 首先创建一个用来发送数据的iframe.</span></span><br><span class="line">    <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">    iframe.name = <span class="string">"iframePost"</span>;</span><br><span class="line">    <span class="comment">//这里一般会通过以下一条命令隐藏iframe，但这里为了显示效果，所以这里就注释掉这一句不隐藏了</span></span><br><span class="line">    <span class="comment">//iframe.style.display = "none";</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">    <span class="keyword">const</span> form = <span class="built_in">document</span>.createElement(<span class="string">"form"</span>);</span><br><span class="line">    <span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span><br><span class="line">    <span class="comment">// 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话.</span></span><br><span class="line">    iframe.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"post success!!"</span>);</span><br><span class="line">        <span class="comment">// 取出返回的信息</span></span><br><span class="line">        <span class="built_in">console</span>.log(iframe.contentWindow.document.getElementsByName(<span class="string">'resinfo'</span>)[<span class="number">0</span>].innerHTML);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 指定请求url</span></span><br><span class="line">    form.action = url;</span><br><span class="line">    <span class="comment">// 在指定的iframe中执行form</span></span><br><span class="line">    form.target = iframe.name;</span><br><span class="line">    form.method = <span class="string">"post"</span>;</span><br><span class="line">    <span class="comment">// 将data中的数据作为新建input赋名称和值，并拼接在form内（逐行数据对应逐行创建input）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> data) &#123;</span><br><span class="line">        node.name = name;</span><br><span class="line">        node.value = data[name].toString();</span><br><span class="line">        form.appendChild(node.cloneNode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表单元素需要添加到主文档中</span></span><br><span class="line">    form.style.display = <span class="string">"none"</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(form);</span><br><span class="line">    form.submit();</span><br><span class="line">    <span class="comment">// 表单提交后,就可以删除这个表单,不影响下次的数据发送.</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(form);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">requestPost(&#123;</span><br><span class="line">    url: <span class="string">"http://localhost:3000/iframe"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">    msg: <span class="string">"helloIframePost"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接着看页面及控制台的提示信息，即可知道请求是否发送成功。</p>
<h5><span id="cors">CORS</span></h5><p>CORS是一个W3C标准，全称”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>这里引用并推荐一下阮一峰老师的文章：</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<p>浏览器将CORS请求划分为：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<ol>
<li>简单请求：</li>
</ol>
<ul>
<li>定义：</li>
</ul>
<p>满足一下两大条件，即为简单请求：</p>
<p>（1) 请求方法是以下三种方法之一：</p>
<ul>
<li><p>HEAD</p>
</li>
<li><p>GET</p>
</li>
<li><p>POST</p>
</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li><p>Accept</p>
</li>
<li><p>Accept-Language</p>
</li>
<li><p>Content-Language</p>
</li>
<li><p>Last-Event-ID</p>
</li>
<li><p>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</p>
</li>
</ul>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<ul>
<li>流程：</li>
</ul>
<p>对于简单请求，浏览器会直接发出CROS请求。具体的说，就是在头部增加一个 Origin 字段，其内容是本次请求的来源（包括协议、域名、端口），服务端会据此决定是否统一这次请求。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出以下几个头信息字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>以上三个 Access-Control- 开头的字段的含义分别为：</p>
<p>（1）Access-Control-Allow-Origin<br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>
<p>（2）Access-Control-Allow-Credentials<br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p>（3）Access-Control-Expose-Headers<br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p>
<p>另外，需要注意的是，如果需要把Cookie发送到服务器，除了服务端设置Access-Control-Allow-Credentials为true之外，还需要在前端发送请求时，给AJAX请求设置withCredentials属性为true，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>否则无论如何，浏览器也不会发送Cookie。</p>
<p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li><p>如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>
</li>
<li><p>不要给浏览器本身设置跨域，否则会导致跨域测试出现问题，比如发送的请求包中的header中没有origin。</p>
</li>
<li><p>withCredential、crossDomain不是header的内容。另外在axios中设置这两者，以下：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials=<span class="literal">true</span>;</span><br><span class="line">axios.defaults.crossDomain=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Access-Control-Expose-Headers、Access-Control-Allow-Methods允许为’*’，表示任意适配。</p>
</li>
<li><p>Cookie是浏览器从服务端发到浏览器的应答包的header中所包含的set-cookie中得来，然后浏览器再根据其域名存储，不同域名/地址之间无法共享。如，macrazds.cn的cookie只能发送给macrazds.cn，而不能发给macrazdhao.cn。</p>
</li>
</ul>
<h5><span id="代理">代理</span></h5><p>这一方法的思路是：浏览器将请求发送到正常的域名，然后有某个处于前后端两者中间东西，负责转发，将浏览器发来的请求发送到真正的后端域名，于是这样就避免了跨域。</p>
<p>emmm。。还需要注意的是，这个方法我没试验过，因为服务器没装Nginx，所以感觉有点麻烦，所以这里就直接搬运了…</p>
<p>Nginx配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    # 监听9099端口</span><br><span class="line">    listen <span class="number">9099</span>;</span><br><span class="line">    # 域名是localhost</span><br><span class="line">    server_name localhost;</span><br><span class="line">    #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 </span><br><span class="line">    location ^~ <span class="regexp">/api &#123;</span></span><br><span class="line"><span class="regexp">        proxy_pass http:/</span><span class="regexp">/localhost:9871;</span></span><br><span class="line"><span class="regexp">    &#125;    </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>前端只需要写接口就好了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求的时候直接用回前端这边的域名http://localhost:9099，这就不会跨域，然后Nginx监听到凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 </span></span><br><span class="line">fetch(<span class="string">'http://localhost:9099/api/iframePost'</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    msg: <span class="string">'helloIframePost'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>来自参考原文的评价：</p>
<p>Nginx转发的方式似乎很方便！但这种使用也是看场景的，如果后端接口是一个公共的API，比如一些公共服务获取天气什么的，前端调用的时候总不能让运维去配置一下Nginx，如果兼容性没问题（IE 10或者以上），CROS才是更通用的做法吧。</p>
<h4><span id="dom查询">Dom查询</span></h4><h5><span id="postmessage">postMessage</span></h5><p>window.postMessage()这个方法是HTML5新增的自带接口，专注于实现不同窗口/页面的跨域通讯。以下示例：</p>
<p>发送方<a href="http://localhost:9099/#/crossDomain：" target="_blank" rel="noopener">http://localhost:9099/#/crossDomain：</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"postMessage"</span>&gt;</span>给http://crossDomain.com:9099发消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"crossDomainIframe"</span> <span class="attr">src</span>=<span class="string">"http://crossdomain.com:9099"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  mounted () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里一定要对来源做校验</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (e.origin === <span class="string">'http://crossdomain.com:9099'</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 来自http://crossdomain.com:9099的结果回复</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 向http://crossdomain.com:9099发消息</span></span></span><br><span class="line"><span class="undefined">    postMessage () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> iframe = <span class="built_in">window</span>.frames[<span class="string">'crossDomainIframe'</span>]</span></span><br><span class="line"><span class="javascript">      iframe.postMessage(<span class="string">'我是[http://localhost:9099], 麻烦你查一下你那边有没有id为app的Dom'</span>, <span class="string">'http://crossdomain.com:9099'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接收方<a href="http://crossdomain.com:9099：" target="_blank" rel="noopener">http://crossdomain.com:9099：</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是http:<span class="comment">//crossdomain.com:9099</span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 这里一定要对来源做校验</span></span><br><span class="line">      <span class="keyword">if</span> (e.origin === <span class="string">'http://localhost:9099'</span>) &#123;</span><br><span class="line">        <span class="comment">// http://localhost:9099发来的信息</span></span><br><span class="line">        <span class="built_in">console</span>.log(e.data)</span><br><span class="line">        <span class="comment">// e.source可以是回信的对象，其实就是http://localhost:9099窗口对象(window)的引用</span></span><br><span class="line">        <span class="comment">// e.origin可以作为targetOrigin</span></span><br><span class="line">        e.source.postMessage(<span class="string">`我是[http://crossdomain.com:9099]，我知道了兄弟，这就是你想知道的结果：<span class="subst">$&#123;<span class="built_in">document</span>.getElementById(<span class="string">'app'</span>) ? <span class="string">'有id为app的Dom'</span> : <span class="string">'没有id为app的Dom'</span>&#125;</span>`</span>, e.origin);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h5><span id="documentdomain">document.domain</span></h5><p>该方法仅适用于同主域名，而不同子域名的iframe跨域。</p>
<p>方法的实现：</p>
<p>如主域名是<a href="http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain" target="_blank" rel="noopener">http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain</a> = crossdomain.com就可以访问各自的window对象了。</p>
<h5><span id="canvas操作图片的跨域问题">canvas操作图片的跨域问题</span></h5><p>具体参考：</p>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/02/crossorigin-canvas-getimagedata-cors/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2018/02/crossorigin-canvas-getimagedata-cors/</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="https://m10.music.126.net/20181112200802/d0ac8d95115b857ccdab9b0435f80026/ymusic/2e28/48b7/332a/2e679030b68713326cbd9a9e89bd86d5.mp3"></li>
                    
                        <li title="1" data-url="https://m10.music.126.net/20181112201324/a91e545956d4597831a40eb4b79f9905/ymusic/7217/4d35/e397/e8a4c958c1ccc710cdc50e857653b08b.mp3"></li>
                    
                        <li title="2" data-url="https://m10.music.126.net/20181112201855/6b18462efcc2a507d83a4dd6d949b8a4/ymusic/4710/249e/573c/7d4424268acf09ea093a601db93e9fe8.mp3"></li>
                    
                        <li title="3" data-url="https://m10.music.126.net/20181112202028/4eeb4ed883ca5e2889e46154ca3a649b/ymusic/2b03/22e6/f23f/b791d95874fe81334b3c0ad84b3f8a3c.mp3"></li>
                    
                        <li title="4" data-url="https://m10.music.126.net/20181112202149/7cfc724b628e60ab60b84a973d10d18f/ymusic/977c/5903/0ab3/3cb88bfb8e0b02a605df59e2f82b7809.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="true" data-ci="335c3413450f9d91a78a" data-cs="ba312c821bf1751ea2220453221efb09460057d4" data-r="macrazdhao.github.io" data-o="macrazdhao" data-a="macrazdhao" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>